<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MoleculeZ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="student">
<meta property="og:type" content="website">
<meta property="og:title" content="MoleculeZ">
<meta property="og:url" content="https://freshmeteor.github.io/blog/index.html">
<meta property="og:site_name" content="MoleculeZ">
<meta property="og:description" content="student">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MoleculeZ">
<meta name="twitter:description" content="student">
  
    <link rel="alternate" href="/blog/atom.xml" title="MoleculeZ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">MoleculeZ</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://freshmeteor.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ComputerNetwork" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/05/28/ComputerNetwork/" class="article-date">
  <time datetime="2018-05-28T09:13:17.000Z" itemprop="datePublished">2018-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/28/ComputerNetwork/">ComputerNetwork</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络学习心得"><a href="#计算机网络学习心得" class="headerlink" title="计算机网络学习心得"></a>计算机网络学习心得</h1><h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><ul>
<li>分组交换机(packet switch)</li>
<li>路由器(router)</li>
<li>链路层交换机(link-later switch)</li>
<li>TCP协议(Transmission Control Protocol)</li>
<li>IP协议(Internet Protocol)</li>
<li>接入网(access network)</li>
<li>分组丢失(丢包)(packet lost)</li>
<li>瓶颈链路(bottleneck link)</li>
</ul>
<h3 id="主要内容与问题"><a href="#主要内容与问题" class="headerlink" title="主要内容与问题"></a><strong>主要内容与问题</strong></h3><h2 id="Access-Network"><a href="#Access-Network" class="headerlink" title="Access Network"></a>Access Network</h2><ol>
<li>residential access(家庭接入)</li>
</ol>
<ul>
<li><p>DSL(Digital Subscriber Line)<br>  deployment: telephone company<br>  upstream: 1Mbps<br>  downstream: 8Mbps<br>  <strong>dedicated!</strong></p>
</li>
<li><p>HFC(Hybrid Fiber Coax)<br>  deployment: TV company<br>  upstream: 2Mbps<br>  downstream: 30Mbps<br>  <strong>shared</strong>  </p>
</li>
</ul>
<ol start="2">
<li>company access(企业接入)  </li>
</ol>
<ul>
<li>Ethernet  </li>
<li>WiFi</li>
</ul>
<ol start="3">
<li>Wireless access networks<h3 id="Physical-Media"><a href="#Physical-Media" class="headerlink" title="Physical Media"></a>Physical Media</h3></li>
</ol>
<ul>
<li>cable  </li>
<li>fiber</li>
<li>radio<h2 id="Network-Core"><a href="#Network-Core" class="headerlink" title="Network Core"></a>Network Core</h2></li>
<li>circuit switching<br>在发送方与接收方之间预留所需资源，可以防止阻塞与资源占用。链路中的电路是通过频分复用(Frequency-Division Multiplexing，FDM)或时分复用(Time-Division Multiplexing，TDM)来实现的。  </li>
</ul>
<ul>
<li>packet switching<br>端到端的时延:在源和目的地之间有N-1台路由器，故有N条路径，一个分组大小为L，传输速率都为R，所以端到端的时延=N*L/R<br>store-and-forward transmission机制，交换机刚开始收到一个分组的第一个比特的时候不能直接转发，要等整个分组都收到以后才能开始转发(报文message分成分组packet，分组再分成几部分发出)<br><strong>丢包</strong>:输出链路被占用，要输出的分组就放入输出缓存，当输出缓存也被占满的时候，到达的分组或已经排队的分组之一将被丢弃。<br>无需预留资源  <h2 id="网络层级结构"><a href="#网络层级结构" class="headerlink" title="网络层级结构"></a>网络层级结构</h2><img src="image1.png" alt="ISP互联">  <h2 id="Delay-packet-loss-and-throughput"><a href="#Delay-packet-loss-and-throughput" class="headerlink" title="Delay, packet loss and throughput"></a>Delay, packet loss and throughput</h2></li>
<li>Four delays:<br>1.nodal processing delay<br>2.queuing delay<br>3.transmission delay(传输时延)<br>4.propagation delay(传播时延)<br><strong>传输时延和传播时延的区别：传输时延(transmission delay)是路由器将分组从内部推出所需要的时间，与分组长度和链路传输速率有关，与路由器之间的距离无关。传播时延(propagation delay)是一个比特从一台路由器向另一台路由器传播所需要的时间，与路由器之间的距离有关，与分组长度和链路传播速率无关。</strong></li>
</ul>
<p><strong>链路传输速率只是用来算路由器内部处理分组比特的，路由器之间传播分组比特的速率是由物理因素(光纤、双绞铜线)决定的！</strong>  </p>
<ul>
<li>throughput:<br>吞吐量取决于最慢速度。如果只有一条数据流通，那吞吐量近似等于链路最小速率。但例如，有5台电脑通过一条链路下载东西，则吞吐量=min{服务器接入链路速率，客户接入链路速率，链路传输速率/5}。  <h2 id="protocol-layers-service-models"><a href="#protocol-layers-service-models" class="headerlink" title="protocol layers, service models"></a>protocol layers, service models</h2><h3 id="top-down-approach"><a href="#top-down-approach" class="headerlink" title="top-down approach"></a><em>top-down approach</em></h3></li>
<li>Internet Layers</li>
</ul>
<ol>
<li>application<br><em>HTTP(web文档的请求与传送), SMTP(电子邮件报文的传输), FTP(端系统之间文件传送), DNS(域名系统)等等</em>。<br>位于应用层的端系统与端系统之间交换信息的分组即为<strong>报文(message)。</strong></li>
<li>transport<br><em>TCP, UDP</em><br>运输层运输的是应用层的报文，所以位于运输层的分组称为<strong>报文段(segment)</strong>。</li>
<li>network<br><em>IP protocol, routing protocol</em><br>网络层传输来自于运输层的报文段，位于网络层的分组称为<strong>数据报(datagram)</strong>。</li>
<li>link<br><em>PPP(point-to-point protocol), Ethernet, WiFi, DOCSIS</em><br>链路层收到网络层的数据报，将该数据报分组发送给下一个结点，在下一个结点再上传回网络层。位于链路层的分组称为<strong>帧(frame)</strong>。</li>
<li>physical<br>链路层是针对帧的，而物理层是针对帧的每一个比特。将每个比特一个一个的在结点中移动。</li>
</ol>
<ul>
<li>Encapsulation(封装)<br>自顶向下包装，再自底向上解开包装实现端到端的数据移动。路由器识别网络层，链路层和物理层，但是交换机只识别链路层和物理层(所以交换机无法识别IP地址)</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><ul>
<li><p><strong>路由器如何知道该将收到的分组发向哪条链路呢？</strong><br>在因特网中每台路由器都有一个转发表，这些转发表可以将目的IP地址(或一部分地址)映射转换成输出链路。而这些转发表可以由路由选择协议(routing protocol)来自动配置。</p>
</li>
<li><p><strong>在存储转发机制中等待分组所有比特接收完毕的时间算作什么时延？</strong><br>传输时延。</p>
</li>
<li><p><strong>Consider sending a packet from a source host to a destination host over a fixed route. List the delay components in the end-to-end delay. Which of these delays are constant and which are variable?</strong><br>Nodal processing delay is variable.<br>Queuing delay is variable, because it depends on if there is a queue in route.<br>Transmission delay is variable. It depends on the size of packet.<br>Propagation delay is constant. Because the distance of two ends is constant.  </p>
</li>
<li><p><strong>Suppose Host A wants to send a large file to Host B. The path from Host A to Host B has three links, of rates R1 = 500kbps, R2 = 2Mbps, and R3 = 1Mbps.</strong><br><em>a. Assuming no other traffic in the network, what is the throughput for the file transfer?</em><br>Because of bottlenet link, the throughput = min{R1,R2,R3} = R1 = 500kbps.<br><em>b. Suppose the file is 4 million bytes. Dividing the file size by the throughput, roughly how long will it take to transfer the file to Host B?</em><br>time = 4000000/500000 = 8s<br><em>c. Repeat(a)and(b), but now with R2 reduced to 100 kbps</em><br>the throughput = 100 kbps<br>time_new = 4000000/100000 = 40s  </p>
</li>
<li><p><strong>What are the five layers in the Internet protocol stack? What are the principal responsibilities of each of these layers?</strong><br><em>application layer</em>: send <strong>message</strong> to transport layer, eg: HTTP, FTP, DNS, SMTP<br><em>transport layer</em>: send <strong>segment</strong> to network layer, recieve <strong>message</strong> from application, eg: TCP, UDP.<br><em>network layer</em>: recieve <strong>segment</strong> from transport layer, send <strong>datagram</strong> to link layer. eg:IP protocol, routing protocol.<br><em>link layer</em>: recieve <strong>datagram</strong> from network layer, send <strong>frame</strong> to physiccal layer. eg: PPP, Wi-Fi, Ehthernet, DOCSIS.<br><em>physical layer</em>: recieve <strong>frame</strong> from link layer. Deal with bit of frame.</p>
</li>
<li><p><strong>Which layers in the Internet protocol stack does a router process? Which layers does a link-layer switch process? Which layers does a host process?</strong><br>路由器处理物理层，链路层和网络层。交换机处理物理层和链路层。主机处理物理层，链路层，网络层，运输层和应用层。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://freshmeteor.github.io/blog/2018/05/28/ComputerNetwork/" data-id="cjhtz47w80000hgu1g3c4qcte" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ComputerNetwork/">ComputerNetwork</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vultr服务器搭建ss心得" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/05/23/vultr服务器搭建ss心得/" class="article-date">
  <time datetime="2018-05-23T06:09:53.000Z" itemprop="datePublished">2018-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/23/vultr服务器搭建ss心得/">vultr服务器搭建ss心得</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="vultr服务器下搭建shadowsocks"><a href="#vultr服务器下搭建shadowsocks" class="headerlink" title="vultr服务器下搭建shadowsocks"></a>vultr服务器下搭建shadowsocks</h1><h3 id="基于Ubuntu的代理服务器搭建"><a href="#基于Ubuntu的代理服务器搭建" class="headerlink" title="基于Ubuntu的代理服务器搭建"></a>基于Ubuntu的代理服务器搭建</h3><p>作为一个科班学生，我觉得自己学会搭建一个服务器是必要操作。虽然搭好了也没有多大用处，墙外的世界也没有什么好看的，英文不好的我确实觉得没什么好看的。hhhhhh</p>
<p>首先，服务器我用的是Vultr的Ubuntu最新版，最便宜的是5刀一个月。限流量但是绝对够用了。在服务器上直接配置操作不方便，可以下载一个Xshell来远程控制服务器，在本地直接进行操作。<a href="https://www.netsarang.com/products/xsh_overview.htm" target="_blank" rel="noopener">Xshell下载地址</a></p>
<p>Xshell操作很简单的，新建会话然后把服务器那边给你的IP和账号（vultr那里账号默认是root）和密码填一下，其他的默认，就可以用了。</p>
<p>进入Ubuntu之后，都是命令行操作。我很呆，我装了一个Ubuntu界面，然后发现下载完shadowsocks之后找不到文件…之后才明白我的安装方式本来就没有装图形界面，要有图形界面得另外一种安装方式，其实也没有必要，没有就没有吧，熟悉一下命令行操作不好吗？</p>
<p>首先下载各种需要的东西：</p>
<ul>
<li><p>需要一个pip环境（此处用的是python版本的shadowsocks，这里提一下lievb，这个是大多数人比较支持的，投票赞同率有60%多，python版本的有30%多，GO版本的有8%，因为lievb内存占用小，速度应该二者差不多。感觉python版本的更好部署一点，我秉着实现优先的原则，就先用pytho版本的试一下）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装pip之后就可以用pip来装shadowsocks了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>
</li>
<li><p>好了，现在可以使用服务器端的shadowsocks了，有两种方法来部署。</p>
<h3 id="第一种方法：直接命令启动"><a href="#第一种方法：直接命令启动" class="headerlink" title="第一种方法：直接命令启动"></a>第一种方法：直接命令启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -p 8388 -k password -m -aes-256-cfb -d start</span><br><span class="line">sudo ssserver -p 8388 -k password -m -aes-256-cfb -d stop</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两行命令分别是启动和关闭，8388是端口，取决于你想开什么端口，-k后面是密码，-m后面是加密方式，我采用的是aes-256-cfb，这个比较安全，但是会慢一些？</p>
<p>然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohop ssserver</span><br></pre></td></tr></table></figure></p>
<p>就可以让它在后台运行了。</p>
<h3 id="第二种方法：配置json文件（这种方式虽然麻烦一些，但却方便查看和修改）"><a href="#第二种方法：配置json文件（这种方式虽然麻烦一些，但却方便查看和修改）" class="headerlink" title="第二种方法：配置json文件（这种方式虽然麻烦一些，但却方便查看和修改）"></a>第二种方法：配置json文件（这种方式虽然麻烦一些，但却方便查看和修改）</h3><p>先切换个目录，默认是etc，在里面用vim指令新建一个json文件，然后配置那个json文件就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br><span class="line">vim shadowsocks.json</span><br></pre></td></tr></table></figure></p>
<p>按回车进入json文件，按i进行insert操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">            &quot;123&quot;:&quot;password&quot;,</span><br><span class="line">            &quot;10000&quot;:&quot;password&quot;,</span><br><span class="line">            &quot;53&quot;:&quot;password&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;timeout&quot;:60,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置完成之后按Esc退出，<strong>然后输入:wq保存json文件并退出。</strong></p>
<p>接下来输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">nohop ssserver</span><br></pre></td></tr></table></figure></p>
<p>就可以了，这时候关闭Xshell，在本地打开客户端shadowsocks尝试一下能否连接服务器。<br>在此之前，先使用telnet试试服务器那边的端口开了没<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet server_ip server_port</span><br></pre></td></tr></table></figure></p>
<p>在客户端使用shadowsocks，填入目标ipv4地址，端口号和密码，以及加密方式，点击确定，然后启动系统代理。可以在帮助那栏看到显示日志，日志上会有一个started。那就是连接成功了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://freshmeteor.github.io/blog/2018/05/23/vultr服务器搭建ss心得/" data-id="cjhtz47xp0004hgu14crtoth4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Computer-Networking/">Computer Networking</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MobileNet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/05/06/MobileNet/" class="article-date">
  <time datetime="2018-05-06T10:50:46.000Z" itemprop="datePublished">2018-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/06/MobileNet/">MobileNet学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MobileNet学习心得——一种高效轻量神经网络"><a href="#MobileNet学习心得——一种高效轻量神经网络" class="headerlink" title="MobileNet学习心得——一种高效轻量神经网络"></a>MobileNet学习心得——一种高效轻量神经网络</h1><h3 id="这是我的第一篇博客。不把自己学到的东西写下来，始终感觉和没学到似的。希望把自己所认识的记录下来，转换成自己真正拥有的-我不想用很官方的语言来些东西，我想用自己的话把道理讲清楚。"><a href="#这是我的第一篇博客。不把自己学到的东西写下来，始终感觉和没学到似的。希望把自己所认识的记录下来，转换成自己真正拥有的-我不想用很官方的语言来些东西，我想用自己的话把道理讲清楚。" class="headerlink" title="这是我的第一篇博客。不把自己学到的东西写下来，始终感觉和没学到似的。希望把自己所认识的记录下来，转换成自己真正拥有的~ 我不想用很官方的语言来些东西，我想用自己的话把道理讲清楚。"></a>这是我的第一篇博客。不把自己学到的东西写下来，始终感觉和没学到似的。希望把自己所认识的记录下来，转换成自己真正拥有的~ 我不想用很官方的语言来些东西，我想用自己的话把道理讲清楚。</h3><p>首先这个MobileNet的论文是谷歌于2017年发表在archive上的，现在时间过去了一年，MobileNet已经有了V2，但是核心是一样的——深度可分离卷积。话不多说，我们一起来看一下深度可分离卷积是个什么情况：</p>
<p><img src="image1.png" alt="深度可分离卷积概念图"></p>

<h3 id="深度可分离卷积可以分成深度卷积核逐点卷积两个部分"><a href="#深度可分离卷积可以分成深度卷积核逐点卷积两个部分" class="headerlink" title="深度可分离卷积可以分成深度卷积核逐点卷积两个部分"></a>深度可分离卷积可以分成深度卷积核逐点卷积两个部分</h3><p>我们先不管这两个卷积，先看一下常规卷积操作：<br><img src="image2.png" alt="常规卷积"><br>输入图片是(7,7,2)，也就是7×7大小2通道的图片，经过1个2通道卷积核的作用得到一个1通道的output。而现实情况是卷积核(filter)的个数会很多，一般比通道数多很多，<strong>而output的通道数其实就等于用于卷积的卷积核个数了。</strong><br>为了加深理解，我用tensorflow进行了一个很简单的实践：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">img1 = tf.constant(value=1,shape = [1,7,7,3], dtype=tf.float32)   </span><br><span class="line">filter = tf.constant(value=1, shape=[5,5,3,6],dtype=tf.float32)   </span><br><span class="line"></span><br><span class="line">out_img = tf.nn.conv2d(input=img1, filter=filter, strides=[1,1,1,1], padding=&apos;VALID&apos;)</span><br><span class="line">print(out_img.shape)</span><br></pre></td></tr></table></figure></p>
<p>这里提一下输入图像和卷积核的shape是有区别的。首先shape定义出来的都是张量（关于张量的解释，知乎上有一个答主说的很清楚：<a href="https://www.zhihu.com/question/20695804/answer/76486670" target="_blank" rel="noopener">张量</a>）</p>
<p>我怕我解释不好误导了你。不过对于图像来说这种低维的东西还是很好理解的。</p>
<ul>
<li>在tensorflow中的输入图像的shape是四阶的，分别代表[batch_size, in_height, in_width, in_channels]</li>
<li>卷积核也是四阶的，分别代表[filter_height, filter_width, in_channerl, out_channels]</li>
</ul>
<p>在常规卷积的情况下，上述代码的out_img.shape打印出来的结果是[1,3,3,6]</p>
<p>了解了常规卷积之后，我们可以来看看深度卷积是什么：<br><img src="image3.png" alt="深度卷积"><br>这张图是横着的，我们比较习惯于看竖着的，不过没关系，道理都是一样的。左边的是输入图像，这是一幅2通道的图像，右边分别是2通道的两个filter。深度卷积的卷积操作就是filter1的第一通道与输入图像第一通道做卷积，得到一张feature map，filter2的第一通道与输入图像第一通道做卷积，得到另一张feature map。以此类推，图中的卷积总共得到4张feature map。然后我们来看一些简单的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">img1 = tf.constant(value=1,shape = [1,7,7,3], dtype=tf.float32)              </span><br><span class="line">filter = tf.constant(value=1, shape=[5,5,3,6],dtype=tf.float32)              </span><br><span class="line">out_img = tf.nn.depthwise_conv2d(input=img1, filter=filter, strides=[1,1,1,1], padding=&apos;VALID&apos;)</span><br><span class="line">print(out_img.shape)</span><br></pre></td></tr></table></figure></p>
<p>上述代码的输出结果是[1,3,3,18]，多尝试几次，我们不难发现，深度卷积的输出结果的通道数完全就是输入图像的in_channels与filter的out_channels的乘积好嘛！官方给出的解释是输出通道=in_channels * channel_multiplier，其实channel_multiplier也就是filter的shape中定义的out_channels了。</p>
<p>可是，还是有人提出疑问，从MobileNet的论文中给出的概念图（文中第一幅图）来看，深度卷积核的每一个滤波器的通道数根本就是1，而测试代码用的滤波器的通道数必须和输入图像的通道数一致，否则会报错！这是为什么呢？也就是说，如果按照概念图的方式来做卷积，将会是一个怎样的情况呢？</p>
<p>会报错</p>
<p><strong>所以我们不能像测试常规卷积一样来测试深度卷积，因为按照论文中所述的原理，是每一个单通道卷积核对输入图像的每一个通道做卷积的，这就是一个</strong>filter对应channel<strong>的形式，所以说，和图一说的一样，输入图像有几通道，深度卷积核就有几个。这样的结果就是牺牲了卷积核个数（因为通常情况下卷积核个数会多于图像通道数），但是减少了计算复杂度。<br>[1,7,7,3]要拆分成3个[1,7,7,1]，分别与3个不同的filter[5,5,1,1]做卷积，得到3个feature map，这3个feature再做逐点常规卷积。</strong></p>
<p>对深度卷积做测试的时候，如果要像图中用单通道的卷积核来处理的话，在代码实现的时候，要把输入图像的shape的通道拆分，比如有M通道就拆成M个张量，这些张量堆叠在一起才形成原图像。这些各个通道的图像与不同的单通道深度卷积核分别做常规卷积，所以说计算复杂度是DK×DK×M×DF×DF就没问题了。</p>
<p> 接下来看深度可分卷积，其实就是做完深度卷积之后，再用1*1大小的卷积核来对输出的特征图做一次常规卷积实现降维，提升网络的表达能力。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> import tensorflow as tf</span><br><span class="line">img1 = tf.constant(value=1,shape = [1,7,7,3], dtype=tf.float32)              </span><br><span class="line">filter = tf.constant(value=1, shape=[5,5,3,6],dtype=tf.float32)              </span><br><span class="line">point_filter = tf.constant(value = 1,shape = [1,1,18,4],dtype=tf.float32)    </span><br><span class="line">out_img = tf.nn.separable_conv2d(input=img1, depthwise_filter=filter,pointwise_filter=point_filter, strides=[1,1,1,1], padding=&apos;VALID&apos;)</span><br><span class="line">print(out_img.shape)</span><br></pre></td></tr></table></figure></p>
<p>separable_conv2d函数比之前多了一个逐点卷积核参数，其实你完全可以调用一次深度卷积，再调用一次常规卷积来实现separable_conv2d。</p>
<p>MobileNet的核心部分讨论完了，现在讨论一下计算复杂度问题（这也是令MobileNet作者引以为豪的东西<em>(:з)∠)</em>）</p>
<p>论文中给出的公式如下：<img src="iamge4.PNG" alt="公式"></p>
<p>分子是深度可分卷积的计算复杂度，分母是常规卷积的计算复杂度。DK是输入图片尺寸，DF是输出图片尺寸，M是卷积核通道数，N是卷积核个数。从结果看，确实比常规卷积快了不少~但是也因为滤波器个数的减少，导致精度有一定的下降~（复杂度公式不能按照代码上定义的张量来算，这只是表面的一个现象，真实情况是代码上面的加黑字体…）</p>
<h2 id="总而言之，深度可分卷积快速的原因是牺牲了卷积核个数（卷积核个数从N减少到了M），但是减少了计算复杂度。"><a href="#总而言之，深度可分卷积快速的原因是牺牲了卷积核个数（卷积核个数从N减少到了M），但是减少了计算复杂度。" class="headerlink" title="总而言之，深度可分卷积快速的原因是牺牲了卷积核个数（卷积核个数从N减少到了M），但是减少了计算复杂度。"></a>总而言之，深度可分卷积快速的原因是牺牲了卷积核个数（卷积核个数从N减少到了M），但是减少了计算复杂度。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://freshmeteor.github.io/blog/2018/05/06/MobileNet/" data-id="cjhtz47xp0003hgu18zukvlam" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/神经网络/">神经网络</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Computer-Networking/">Computer Networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/ComputerNetwork/">ComputerNetwork</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/神经网络/">神经网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Computer-Networking/" style="font-size: 10px;">Computer Networking</a> <a href="/blog/tags/ComputerNetwork/" style="font-size: 10px;">ComputerNetwork</a> <a href="/blog/tags/神经网络/" style="font-size: 10px;">神经网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/05/">五月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2018/05/28/ComputerNetwork/">ComputerNetwork</a>
          </li>
        
          <li>
            <a href="/blog/2018/05/23/vultr服务器搭建ss心得/">vultr服务器搭建ss心得</a>
          </li>
        
          <li>
            <a href="/blog/2018/05/06/MobileNet/">MobileNet学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 FreshMeteor<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>